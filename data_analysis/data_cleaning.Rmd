---
title: "Blockchain Project"
author: "Yang Yujie 3036044363"
date: "2024-07-11"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




# token_house

```{r}
prop_token = read.csv("/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/token_house_proposals_votes.csv")


colnames(prop_token)
```
```{r}
apply(prop_token,2,function(x) length(unique(x)))
```
有一些proposal没有title

```{r}
apply(prop_token,2,typeof)
```




```{r}
library(dplyr)


token_number_people =  prop_token  %>% group_by(proposal_id) %>% summarise(number_people= length(unique(address)))

table(token_number_people$number_people)
```
绝大部分proposal都是200个人都投票了。(看是否能去掉投票少的proposal，看一下voting——power)





```{r}
# 过滤掉参与次数较少的address

token_address_num =  prop_token  %>% group_by(address) %>% summarise(number_prop= length(unique(proposal_id)))

length(unique(prop_token$address))
token_address_num %>% filter(number_prop >= 5 ) %>% dim
token_address_num_5 = token_address_num %>% filter(number_prop >= 5 )

prop_token_filter = prop_token %>% filter(address %in% token_address_num_5$address)

```

Nearly a half of address in the token house only participate in less than 5 proposals.



# citizen house

```{r}


prop_cit = read.csv('/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/citizen_house_proposals_votes2.csv')

#cit2 = read.csv('/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/citizen_house_proposals_votes2.csv')

unique(prop_cit$voted_choice)

colnames(prop_cit)
```

```{r}
# 清洗voted——choice
prop_cit = prop_cit %>% mutate(voted_choice= replace(voted_choice,voted_choice %in% c("No, don't consider profit at all","Veto"), "AGAINST"))

prop_cit = prop_cit %>% mutate(voted_choice= replace(voted_choice,voted_choice %in% c("No Veto " ,"Yes, ratify","No Veto" ,"No Veto (Approve)"), "FOR"))


prop_cit = prop_cit %>% filter(!voted_choice %in% c("Test Option A","Test Option B") )
unique(prop_cit$voted_choice)

```


```{r}
apply(prop_cit,2,function(x) length(unique(x)))

```
proposal, proposal_id ，snapshot and title 是一一对应的。因此此处只保留一列即可，保留id.

```{r}
library(dplyr)


cit_number_people =  prop_cit  %>% group_by(proposal_id) %>% summarise(number_people = length(unique(address)))

table(cit_number_people$number_people)
```




```{r}
# 过滤掉参与次数较少的address

cit_address_num =  prop_cit  %>% group_by(address) %>% summarise(number_prop= length(unique(proposal_id)))

length(unique(prop_cit$address))
cit_address_num %>% filter(number_prop >= 5 ) %>% dim
cit_address_num_5 = cit_address_num %>% filter(number_prop >= 5 )

prop_cit_filter = prop_cit %>% filter(address %in% cit_address_num_5$address)

```



# Between token and citizen

```{r}
prop_token %>% distinct() %>% dim()

prop_cit %>% distinct() %>% dim()

prop_token_filter %>% distinct() %>% dim()

prop_cit_filter %>% distinct() %>% dim()
```
两个数据表中没有重复的行。

```{r}
# 查找两列的相同元素

length(intersect(unique(prop_token$address),unique(prop_cit$address)))

length(intersect(unique(prop_token_filter$address),unique(prop_cit_filter$address)))

length(intersect(unique(prop_token_filter$proposal_id),unique(prop_cit_filter$proposal_id)))
```

token$address and cit$address一一对应，有16个同时在token 和 cit中出现。（token 和 cit 的address人数各有1000，66个左右）


token house , cit house 中没有相同的proposal id




# voting results

```{r}
voting_res = read.csv('/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/voting_results_summary2.csv')

colnames(voting_res)
```

```{r}
voting_res = voting_res %>% mutate(voted_choice= replace(voted_choice,voted_choice %in% c("No, don't consider profit at all","Veto"), "AGAINST"))

voting_res = voting_res %>% mutate(voted_choice= replace(voted_choice,voted_choice %in% c("No Veto " ,"Yes, ratify","No Veto" ,"No Veto (Approve)"), "FOR"))





voting_res = voting_res %>% filter(!voted_choice %in% c("Test Option A","Test Option B") )

apply(voting_res,2,typeof)
```
```{r}
intersect(unique(prop_cit$proposal_id),unique(prop_token$proposal_id))
length(unique(prop_cit$proposal_id))
length(unique(prop_token$proposal_id))
length(unique(voting_res$proposal_id))
```
投票结果中proposal的数量和cit+token的proposal数量对上了。


```{r}
length(unique(prop_token$proposal_id)) # 76
length(intersect(unique(prop_token$proposal_id),unique(voting_res$proposal_id))) # 

length(unique(prop_cit$proposal_id)) # 12
length(intersect(unique(prop_cit$proposal_id),unique(voting_res$proposal_id))) # 12



```
voting_res的清洗有点问题,有的proposal是multiple，所以for就是0


先不考虑 abstain 和 multiple选择的
```{r}

voting_res %>% filter(voted_choice %in% c('FOR','AGAINST')) %>% dim()

prop_token_filter %>% filter(voted_choice%in% c('FOR','AGAINST')) %>% dim()

prop_cit_filter %>% filter(voted_choice %in% c('FOR','AGAINST')) %>% dim()

voting_res_filter =voting_res %>% filter(voted_choice %in% c('FOR','AGAINST')) 

prop_token_filter = prop_token_filter %>% filter(voted_choice%in% c('FOR','AGAINST')) 

prop_cit_filter = prop_cit_filter %>% filter(voted_choice %in% c('FOR','AGAINST')) 
```
```{r}
#把proposal最终结果信息加入进来
 length(intersect(unique(prop_token_filter$proposal_id),unique(voting_res_filter$proposal_id)))
 length(intersect(unique(prop_cit_filter$proposal_id),unique(voting_res_filter$proposal_id)))
length(unique(prop_token_filter$proposal_id))
length(unique(prop_cit_filter$proposal_id))
## token 和 cit中的proposal都在voting result里面
library(dplyr)
colnames(voting_res_filter)[5] = 'proposal_choice'


voting_res_filter_final = data.frame() ##因为voting res filter里面一个prop id有两行数据，分别是For的票数和Ag的票数，现在需要比较大小，得出一个最终结论。

for (i in 1:unique(length(voting_res_filter$proposal_id))) {
  D = voting_res_filter %>% filter(proposal_id == unique(voting_res_filter$proposal_id)[i])
  if(dim(D)[1]==2){
  D_for = D %>% filter(proposal_choice=='FOR')
  D_for_p = D_for$voting_power
   D_Ag = D %>% filter(proposal_choice=='AGAINST')
  D_Ag_p = D_Ag$voting_power
  
  if (D_for_p>D_Ag_p) {
    voting_res_filter_final = rbind(voting_res_filter_final,D_for)
  } else{
    voting_res_filter_final = rbind(voting_res_filter_final,D_Ag)
  }
  }# end dim(D)[1]==2
  else{
    voting_res_filter_final = rbind(voting_res_filter_final,D)
  }
}

prop_token_filter_add = merge(voting_res_filter_final[c('proposal_id','proposal_choice')],prop_token_filter[c('address','proposal_id','voted_choice')],by = 'proposal_id')


prop_cit_filter_add = merge(voting_res_filter_final[c('proposal_id','proposal_choice')],prop_cit_filter[c('address','proposal_id','voted_choice')],by = 'proposal_id')


dim(prop_token_filter)
dim(prop_cit_filter)
```








```{r}
#算token中，每两人参与了有多少共同的proposal
token_1 = prop_token_filter %>% filter(address == unique(address)[1])
token_2 = prop_token_filter %>% filter(address == unique(address)[2])
token_12 = inner_join(token_1,token_2,by = 'proposal_id')

length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

M = matrix(rep(0,length(unique(prop_token_filter$address))^2),nrow =length(unique(prop_token_filter$address)) )

for (i in 1:length(unique(prop_token_filter$address))) {
  for (j in i:length(unique(prop_token_filter$address))) {
    token_1 = prop_token_filter %>% filter(address == unique(address)[i])
    token_2 = prop_token_filter %>% filter(address == unique(address)[j])
    M[i,j] = length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

  }
  
}

write.csv(data.frame(M),file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_token.csv')
```



```{r}
#算cit中，共同参与的proposal数量
token_1 = prop_cit_filter %>% filter(address == unique(address)[1])
token_2 = prop_cit_filter %>% filter(address == unique(address)[2])
token_12 = inner_join(token_1,token_2,by = 'proposal_id')

length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

cit_M = matrix(rep(0,length(unique(prop_cit_filter$address))^2),nrow =length(unique(prop_cit_filter$address)) )

for (i in 1:length(unique(prop_cit_filter$address))) {
  for (j in i:length(unique(prop_cit_filter$address))) {
    token_1 = prop_cit_filter %>% filter(address == unique(address)[i])
    token_2 = prop_cit_filter %>% filter(address == unique(address)[j])
    cit_M[i,j] = length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

  }
  
}

write.csv(data.frame(cit_M),file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_cit.csv')
```



 






```{r}
#算token and cit house中，每两个人意见一致的proposal数量。
token_1 = prop_token_filter_add %>% filter(address == unique(address)[1])
token_2 = prop_token_filter_add %>% filter(address == unique(address)[2])
token_12 = inner_join(token_1,token_2,by = 'proposal_id')

length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

M_token = matrix(rep(0,length(unique(prop_token_filter_add$address))^2),nrow =length(unique(prop_token_filter_add$address)) )

for (i in 1:length(unique(prop_token_filter_add$address))) {
  for (j in i:length(unique(prop_token_filter_add$address))) {
    token_1 = prop_token_filter_add %>% filter(address == unique(address)[i])
    token_1 = token_1[c('proposal_id','proposal_choice')]
    token_2 = prop_token_filter_add %>% filter(address == unique(address)[j])
    token_2 = token_2[c('proposal_id','proposal_choice')]
    
    M_token[i,j] = dim(intersect(token_1,token_2))[1]

  }
  
}

write.csv(data.frame(M_token),file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_token_samechoice.csv')
####
#token_1 = prop_cit_filter_add %>% filter(address == unique(address)[1])
#token_2 = prop_cit_filter_add %>% filter(address == unique(address)[2])
#token_12 = inner_join(token_1,token_2,by = 'proposal_id')

length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

M_cit = matrix(rep(0,length(unique(prop_cit_filter_add$address))^2),nrow =length(unique(prop_cit_filter_add$address)) )

for (i in 1:length(unique(prop_cit_filter_add$address))) {
  for (j in i:length(unique(prop_cit_filter_add$address))) {
    token_1 = prop_cit_filter_add %>% filter(address == unique(address)[i])
    token_1 = token_1[c('proposal_id','proposal_choice')]
    token_2 = prop_cit_filter_add %>% filter(address == unique(address)[j])
    token_2 = token_2[c('proposal_id','proposal_choice')]
    
    M_cit[i,j] = dim(intersect(token_1,token_2))[1]

  }
  
}

write.csv(data.frame(M_cit),file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_cit_samechoice.csv')
```

```{r}
M_cit = read.csv(file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_cit_samechoice.csv')
# 把三角矩阵变成全矩阵
M_cit = M_cit[,-1]
M_cit_full = as.matrix(M_cit)

for (i in 2:dim(M_cit_full)[1]) {
  for (j in 1:(i-1)) {
    M_cit_full[i,j] = M_cit[j,i]
  }
}

sum(M_cit_full == t(M_cit_full))

dim(M_cit_full)
#########


M_token = read.csv(file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_token_samechoice.csv')
# 把三角矩阵变成全矩阵
M_token = M_token[,-1]
M_token_full = as.matrix(M_token)

for (i in 2:dim(M_token_full)[1]) {
  for (j in 1:(i-1)) {
    M_token_full[i,j] = M_token[j,i]
  }
}


sum(M_token_full == t(M_token_full))

dim(M_token_full)
```


# visualize

## for token

```{r}
M_token_tranc = M_token_full
for (i in dim(M_token_full)[1]) {
  for (j in dim(M_token_full)[1]) {
    if (M_token_tranc[i,j]<= 3) {
      M_token_tranc[i,j] = 0
    }
  }
}

# 安装并加载 igraph 包
#install.packages("igraph")
library(igraph)

# 示例相似性矩阵
similarity_matrix <- M_token_tranc

# 创建图对象
g <- graph_from_adjacency_matrix(similarity_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

# 设置图形布局
layout <- layout_with_fr(g)

# 设置节点颜色和大小
V(g)$color <- "skyblue"
V(g)$size <- 1

# 设置边的宽度和颜色
E(g)$width <- E(g)$weight * 2
E(g)$color <- "grey"

# 绘制美化后的网络图
plot(g, layout = layout, edge.arrow.size = 0.2, vertex.label.color = "black", vertex.label.dist = 1.5)

# 进行Louvain社团检测
community <- cluster_louvain(g,resolution = 1.5) #resolution越大，社团数越多

# 使用 Leiden 算法进行社团划分
community_leiden <- cluster_leiden(g, resolution_parameter = 2)


### 试图进行调优参数
best_mod = 0
best_res = 0
for (i in seq(0.01,3,0.01)) {
  community <- cluster_louvain(g,resolution = i)
  mod = modularity(community)
  if (mod>best_mod || mod>0.1) {
    best_mod = mod
    best_res = i
  }
}

community <- cluster_louvain(g,resolution = best_res)

#但发现使模块度最大的参数，造成只有一个group，显然不行。


# 打印社区结构
print(community)
print(community_leiden)

# 绘制网络图，按照社团进行着色
plot(community, g, vertex.size = 15, vertex.label = NA, 
     edge.arrow.size = 0.5, 
     vertex.color = membership(community) + 1)


```

```{r}
library(ggplot2)
Louvain_member = community$membership  #这个的效果感觉更好
leiden_member = community_leiden$membership

#print(leiden_member)
table(Louvain_member)
table(leiden_member)



token_row_sum = rowSums(M_token_full)
length(unique(prop_token_filter$address))# prop_token_filter中的address数量和矩阵一一对应



hist(token_row_sum[leiden_member==1])

hist(token_row_sum[leiden_member==2])

hist(token_row_sum[leiden_member==3])

hist(token_row_sum[Louvain_member==4])

hist(token_row_sum[Louvain_member==5])

hist(token_row_sum[Louvain_member==6])
###
d = prop_token_filter %>% filter(address %in% unique(address)[Louvain_member==4] )
hist(d$voting_power)

d = prop_token_filter %>% filter(address %in% unique(address)[Louvain_member==5] )
hist(d$voting_power)

d = prop_token_filter %>% filter(address %in% unique(address)[Louvain_member==6] )
hist(d$voting_power)

```

```{r}
K_Lou = prop_token_filter %>% filter(address == unique(address)[Louvain_member==48])
mean(K_Lou$voting_power)
#1-682434.4
K_Lei = prop_token_filter %>% filter(address == unique(address)[leiden_member==25])
mean(K_Lei$voting_power)

#1-1997128


# 把那些一个人成一个社区的挑出来
freq= table(Louvain_member)
Lou_1 = as.numeric(names(freq[freq == 1]))

K_Lou_1 = prop_token_filter %>% filter(address %in% unique(address)[Louvain_member%in%as.numeric(names(freq[freq == 1]))])

hist(K_Lou_1$voting_power)
###
freq= table(leiden_member)
Lei_1 = as.numeric(names(freq[freq == 1]))

K_Lei_1 = prop_token_filter %>% filter(address %in% unique(address)[leiden_member%in%as.numeric(names(freq[freq == 1]))])

hist(K_Lei_1$voting_power)


hist(token_row_sum[leiden_member%in%Lei_1])

hist(token_row_sum[Louvain_member%in%Lou_1])


```

选择Lou

## for cit

```{r}
M_cit_tranc = M_cit_full
for (i in dim(M_cit_full)[1]) {
  for (j in dim(M_cit_full)[1]) {
    if (M_cit_tranc[i,j]<= 3) {
      M_cit_tranc[i,j] = 0
    }
  }
}

# 安装并加载 igraph 包
#install.packages("igraph")
library(igraph)

# 示例相似性矩阵
similarity_matrix <- M_cit_tranc

# 创建图对象
g_cit <- graph_from_adjacency_matrix(similarity_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

# 设置图形布局
layout <- layout_with_fr(g_cit)

# 设置节点颜色和大小
V(g_cit)$color <- "skyblue"
V(g_cit)$size <- 1

# 设置边的宽度和颜色
E(g_cit)$width <- E(g_cit)$weight * 2
E(g_cit)$color <- "grey"

# 绘制美化后的网络图
plot(g_cit, layout = layout, edge.arrow.size = 0.2, vertex.label.color = "black", vertex.label.dist = 1.5)

# 进行Louvain社团检测
community_cit <- cluster_louvain(g_cit,resolution = 1.5) #resolution越大，社团数越多

# 使用 Leiden 算法进行社团划分
community_leiden_cit <- cluster_leiden(g_cit, resolution_parameter = 2)


### 试图进行调优参数
best_mod_cit = 0
best_res_cit = 0
for (i in seq(0.01,3,0.01)) {
  community <- cluster_louvain(g_cit,resolution = i)
  mod = modularity(community)
  if (mod>best_mod || mod>0.1) {
    best_mod_cit = mod
    best_res_cit = i
  }
}

community_cit <- cluster_louvain(g_cit,resolution = best_res_cit)

#但发现使模块度最大的参数，造成只有一个group，显然不行。


# 打印社区结构
print(community_cit)
print(community_leiden_cit)

# 绘制网络图，按照社团进行着色
plot(community_cit, g_cit, vertex.size = 15, vertex.label = NA, 
     edge.arrow.size = 0.5, 
     vertex.color = membership(community_cit) + 1)


```
```{r}
library(ggplot2)
Louvain_member_cit = community_cit$membership  #这个的效果感觉更好
leiden_member_cit = community_leiden_cit$membership

#print(leiden_member)
table(Louvain_member_cit)
table(leiden_member_cit)

##Louvain is better

cit_row_sum = rowSums(M_cit_full)
length(unique(prop_cit_filter$address))# prop_token_filter中的address数量和矩阵一一对应





#hist(cit_row_sum[Louvain_member==10])

#hist(cit_row_sum[Louvain_member==33])

#hist(cit_row_sum[Louvain_member==46])
###
#d = prop_cit_filter %>% filter(address %in% unique(address)[Louvain_member_cit==10] )
#hist(d$voting_power)

#d = prop_cit_filter %>% filter(address %in% unique(address)[Louvain_member_cit==33] )
#hist(d$voting_power)



```
```{r}



# 把那些一个人成一个社区的挑出来
freq_cit= table(Louvain_member_cit)
Lou_cit_1 = as.numeric(names(freq_cit[freq_cit == 1]))

K_Lou_cit_1 = prop_cit_filter %>% filter(address %in% unique(address)[Louvain_member_cit%in%as.numeric(names(freq_cit[freq_cit == 1]))])

hist(K_Lou_cit_1$voting_power)
###
freq_cit= table(leiden_member_cit)
Lei_cit_1 = as.numeric(names(freq_cit[freq_cit == 1]))

K_Lei_cit_1 = prop_cit_filter %>% filter(address %in% unique(address)[leiden_member_cit%in%as.numeric(names(freq_cit[freq_cit == 1]))])

hist(K_Lei_cit_1$voting_power)


hist(cit_row_sum[leiden_member_cit%in%Lei_cit_1])

hist(cit_row_sum[Louvain_member_cit%in%Lou_cit_1])


```

# logistics reg

## for token
```{r}
# 数据类型转换
# 将 group 中的 "A" 转换为 1，"B" 转换为 0，其他值不变
df_token = prop_token_filter_add
df_token$proposal_choice_ <- ifelse(prop_token_filter_add$proposal_choice=='FOR',1,0) 
df_token$voted_choice_ <- ifelse(prop_token_filter_add$voted_choice=='FOR',1,0) 




```


```{r}


#Louvain_member
##
address_token = unique(prop_token_filter_add$address)
# define a vector to store the effect of everyone
log_eff_token = rep(0,length(unique(prop_token_filter_add$address)))
for (i in 1:length(log_eff_token)) {
  df = df_token %>% filter(address==address_token[i])
  log_model <- glm(proposal_choice_ ~ voted_choice_, data = df, family = binomial)
  log_eff_token[i]=log_model$coefficients[2]
  
}

# 计算na的占比
sum(is.na(log_eff_token))/length(log_eff_token)

hist(log_eff_token)
```

```{r}
# give same effect to the elements in the same group
ad_log_eff_token = rep(0,length(log_eff_token))
table(Louvain_member)
max(Louvain_member)
for (i in 1:max(Louvain_member)) {
  if (sum(Louvain_member==i)==1) {
    ad_log_eff_token[i]=mean(log_eff_token[i],na.rm = T)
  }
  else{
    a = log_eff_token[Louvain_member==i]
    a = a[!is.na(a)]
    ad_log_eff_token[Louvain_member==i] = rep(mean(a,na.rm = TRUE),sum(Louvain_member==i))
  }
  
}

ad_log_eff_token
# 出现NA是因为那一个人就是一个group，且他的效益为NA，因为他的投票和proposal完全一致。 出现-NaN是因为在拥有多个成员的group中，其中的成员效应全是NA
#Louvain_member[ad_log_eff==-NaN]
Louvain_member[is.nan(ad_log_eff_token)]
log_eff_token[Louvain_member==6]
ad_log_eff_token[Louvain_member==6]
hist(ad_log_eff_token[!is.nan(ad_log_eff_token)])
```


```{r}
table(Louvain_member)
var(ad_log_eff_token[!is.nan(ad_log_eff_token)])

```

## for cit

```{r}
# 转换FOR 和 AGAINST 为 1，0方便逻辑回归
df_cit = prop_cit_filter_add
df_cit$proposal_choice_ <- ifelse(prop_cit_filter_add$proposal_choice=='FOR',1,0) 
df_cit$voted_choice_ <- ifelse(prop_cit_filter_add$voted_choice=='FOR',1,0) 
```

```{r}


#Louvain_member
##
address_cit = unique(prop_cit_filter_add$address)
# define a vector to store the effect of everyone
log_eff_cit = rep(0,length(unique(prop_cit_filter_add$address)))
for (i in 1:length(log_eff_cit)) {
  df = df_cit %>% filter(address==address_cit[i])
  log_model <- glm(proposal_choice_ ~ voted_choice_, data = df, family = binomial)
  log_eff_cit[i]=log_model$coefficients[2]
  
}

# 计算na的占比
sum(is.na(log_eff_cit))/length(log_eff_cit)

hist(log_eff_cit)
```

```{r}
# give same effect to the elements in the same group
ad_log_eff_cit = rep(0,length(log_eff_cit))
table(Louvain_member_cit)
max(Louvain_member_cit)
for (i in 1:max(Louvain_member_cit)) {
  if (sum(Louvain_member_cit==i)==1) {
    ad_log_eff_cit[i]=mean(log_eff_cit[i],na.rm = T)
  }
  else{
    a = log_eff_cit[Louvain_member_cit==i]
    a = a[!is.na(a)]
    ad_log_eff_cit[Louvain_member_cit==i] = rep(mean(a,na.rm = TRUE),sum(Louvain_member_cit==i))
  }
  
}

ad_log_eff_cit
# 出现NA是因为那一个人就是一个group，且他的效益为NA，因为他的投票和proposal完全一致。 出现-NaN是因为在拥有多个成员的group中，其中的成员效应全是NA
#Louvain_member[ad_log_eff==-NaN]
Louvain_member_cit[is.nan(ad_log_eff_cit)]
log_eff_cit[Louvain_member_cit==6]
ad_log_eff_cit[Louvain_member_cit==6]
hist(ad_log_eff_cit[!is.nan(ad_log_eff_cit)])
```


```{r}
table(Louvain_member_cit)
var(ad_log_eff_cit[!is.nan(ad_log_eff_cit)])
var(log_eff_cit[!is.na(log_eff_cit)])
```

## for both

```{r}
Both = intersect(unique(prop_token_filter$address),unique(prop_cit_filter$address))
match(Both,address_token) #同时在token和cit中出现的人的位置
ad_log_eff_both = ad_log_eff_token[match(Both,address_token)]
hist(ad_log_eff_both[!is.nan(ad_log_eff_both)])

```




```{r}


#Louvain_member
##
address_both = Both
# define a vector to store the effect of everyone
log_eff_both = rep(0,length(address_both))
for (i in 1:length(log_eff_both)) {
  df1 = df_token %>% filter(address==address_both[i])
  df2 = df_cit %>% filter(address==address_both[i])
  df = rbind(df1,df2)
  log_model <- glm(proposal_choice_ ~ voted_choice_, data = df, family = binomial)
  log_eff_both[i]=log_model$coefficients[2]
  
}

# 计算na的占比
sum(is.na(log_eff_both))/length(log_eff_both)

hist(log_eff_both)
```



# anti-realistic

## for token
```{r}

log_eff_token_rev = rep(0,length(log_eff_token))

#在转换时,还是一个一个转换
for (i in 1:length(log_eff_token)) {
  
    prop_token_filter_rev =prop_token_filter
    prop_token_filter_rev$voted_choice[prop_token_filter_rev$address==address_token[i]] =   ifelse(prop_token_filter_rev$voted_choice[prop_token_filter_rev$address==address_token[i]] == 'FOR','AGAINST','FOR')
###
voting_res_token_rev = prop_token_filter_rev %>% group_by(proposal_id)  %>% summarise(
  For_result = sum(voting_power[voted_choice=='FOR']),
  Against_result = sum(voting_power[voted_choice=='AGAINST']))

voting_res_token_rev = voting_res_token_rev %>% mutate(
  proposal_choice = ifelse(For_result>Against_result,'FOR','AGAINST'))
#目前得到新的proposal结果：voting_res_token_rev

    
   
#现在合并数据
prop_token_filter_rev_add = merge(voting_res_token_rev[c('proposal_id','proposal_choice')],prop_token_filter_rev[c('address','proposal_id','voted_choice')],by = 'proposal_id')
#转换数据类型
df_token = prop_token_filter_rev_add
df_token$proposal_choice_ <- ifelse(prop_token_filter_rev_add$proposal_choice=='FOR',1,0) 
df_token$voted_choice_ <- ifelse(prop_token_filter_rev_add$voted_choice=='FOR',1,0) 


df = df_token[df_token$address==address_token[i],]
  log_model <- glm(proposal_choice_ ~ voted_choice_, data = df, family = binomial)
  log_eff_token_rev[i]=log_model$coefficients[2]

  
  
} # end for


hist(log_eff_token_rev)


```

```{r}
# give same effect to the elements in the same group
ad_log_eff_token_rev = rep(0,length(log_eff_token_rev))
table(Louvain_member)
max(Louvain_member)
for (i in 1:max(Louvain_member)) {
  if (sum(Louvain_member==i)==1) {
    ad_log_eff_token_rev[i]=mean(log_eff_token_rev[i],na.rm = T)
  }
  else{
    a = log_eff_token_rev[Louvain_member==i]
    a = a[!is.na(a)]
    ad_log_eff_token_rev[Louvain_member==i] = rep(mean(a,na.rm = TRUE),sum(Louvain_member==i))
  }
  
}

ad_log_eff_token_rev
# 出现NA是因为那一个人就是一个group，且他的效益为NA，因为他的投票和proposal完全一致。 出现-NaN是因为在拥有多个成员的group中，其中的成员效应全是NA
#Louvain_member[ad_log_eff==-NaN]

hist(ad_log_eff_token_rev[!is.nan(ad_log_eff_token_rev)])
```

```{r}
summary(log_eff_token_rev)
```



```{r}
#看一下每个人的voting power总量分布
d_vp = prop_token_filter %>% group_by(address) %>% summarise(tot_vp = sum(voting_power))
hist(d_vp$tot_vp)
summary(d_vp$tot_vp)
```

## for cit

```{r}

log_eff_cit_rev = rep(0,length(log_eff_cit))

#在转换时,还是一个一个转换
for (i in 1:length(log_eff_cit)) {
  
    prop_cit_filter_rev =prop_cit_filter
    prop_cit_filter_rev$voted_choice[prop_cit_filter_rev$address==address_cit[i]] =   ifelse(prop_cit_filter_rev$voted_choice[prop_cit_filter_rev$address==address_cit[i]] == 'FOR','AGAINST','FOR')
###
voting_res_cit_rev = prop_cit_filter_rev %>% group_by(proposal_id)  %>% summarise(
  For_result = sum(voting_power[voted_choice=='FOR']),
  Against_result = sum(voting_power[voted_choice=='AGAINST']))

voting_res_cit_rev = voting_res_cit_rev %>% mutate(
  proposal_choice = ifelse(For_result>Against_result,'FOR','AGAINST'))
#目前得到新的proposal结果：voting_res_cit_rev

    
   
#现在合并数据
prop_cit_filter_rev_add = merge(voting_res_cit_rev[c('proposal_id','proposal_choice')],prop_cit_filter_rev[c('address','proposal_id','voted_choice')],by = 'proposal_id')
#转换数据类型
df_cit = prop_cit_filter_rev_add
df_cit$proposal_choice_ <- ifelse(prop_cit_filter_rev_add$proposal_choice=='FOR',1,0) 
df_cit$voted_choice_ <- ifelse(prop_cit_filter_rev_add$voted_choice=='FOR',1,0) 


df = df_cit[df_cit$address==address_cit[i],]
  log_model <- glm(proposal_choice_ ~ voted_choice_, data = df, family = binomial)
  log_eff_cit_rev[i]=log_model$coefficients[2]

  
  
} # end for


hist(log_eff_cit_rev)


```

```{r}
# give same effect to the elements in the same group
ad_log_eff_cit_rev = rep(0,length(log_eff_cit_rev))
table(Louvain_member_cit)
max(Louvain_member_cit)
for (i in 1:max(Louvain_member_cit)) {
  if (sum(Louvain_member_cit==i)==1) {
    ad_log_eff_cit_rev[i]=mean(log_eff_cit_rev[i],na.rm = T)
  }
  else{
    a = log_eff_cit_rev[Louvain_member_cit==i]
    a = a[!is.na(a)]
    ad_log_eff_cit_rev[Louvain_member_cit==i] = rep(mean(a,na.rm = TRUE),sum(Louvain_member_cit==i))
  }
  
}

ad_log_eff_cit_rev
# 出现NA是因为那一个人就是一个group，且他的效益为NA，因为他的投票和proposal完全一致。 出现-NaN是因为在拥有多个成员的group中，其中的成员效应全是NA
#Louvain_member[ad_log_eff==-NaN]

hist(ad_log_eff_cit_rev[!is.nan(ad_log_eff_cit_rev)])
```

```{r}
summary(log_eff_cit_rev)
```



```{r}
#看一下每个人的voting power总量分布
d_vp = prop_cit_filter %>% group_by(address) %>% summarise(tot_vp = sum(voting_power))
hist(d_vp$tot_vp)
summary(d_vp$tot_vp)
```



## for both

```{r}

log_eff_both_rev = rep(0,length(log_eff_both))

#在转换时,还是一个一个转换
for (i in 1:length(log_eff_both)) {
  
## token
    prop_token_filter_rev =prop_token_filter
    prop_token_filter_rev$voted_choice[prop_token_filter_rev$address==address_both[i]] =   ifelse(prop_token_filter_rev$voted_choice[prop_token_filter_rev$address==address_both[i]] == 'FOR','AGAINST','FOR')
###
voting_res_token_rev = prop_token_filter_rev %>% group_by(proposal_id)  %>% summarise(
  For_result = sum(voting_power[voted_choice=='FOR']),
  Against_result = sum(voting_power[voted_choice=='AGAINST']))

voting_res_token_rev = voting_res_token_rev %>% mutate(
  proposal_choice = ifelse(For_result>Against_result,'FOR','AGAINST'))
#目前得到新的proposal结果：voting_res_token_rev

    
   
#现在合并数据
prop_token_filter_rev_add = merge(voting_res_token_rev[c('proposal_id','proposal_choice')],prop_token_filter_rev[c('address','proposal_id','voted_choice')],by = 'proposal_id')
#转换数据类型
df_token = prop_token_filter_rev_add
df_token$proposal_choice_ <- ifelse(prop_token_filter_rev_add$proposal_choice=='FOR',1,0) 
df_token$voted_choice_ <- ifelse(prop_token_filter_rev_add$voted_choice=='FOR',1,0) 


df1 = df_token[df_token$address==address_both[i],]


## cit

 prop_cit_filter_rev =prop_cit_filter
    prop_cit_filter_rev$voted_choice[prop_cit_filter_rev$address==address_both[i]] =   ifelse(prop_cit_filter_rev$voted_choice[prop_cit_filter_rev$address==address_both[i]] == 'FOR','AGAINST','FOR')
###
voting_res_cit_rev = prop_cit_filter_rev %>% group_by(proposal_id)  %>% summarise(
  For_result = sum(voting_power[voted_choice=='FOR']),
  Against_result = sum(voting_power[voted_choice=='AGAINST']))

voting_res_cit_rev = voting_res_cit_rev %>% mutate(
  proposal_choice = ifelse(For_result>Against_result,'FOR','AGAINST'))
#目前得到新的proposal结果：voting_res_cit_rev

    
   
#现在合并数据
prop_cit_filter_rev_add = merge(voting_res_cit_rev[c('proposal_id','proposal_choice')],prop_cit_filter_rev[c('address','proposal_id','voted_choice')],by = 'proposal_id')
#转换数据类型
df_cit = prop_cit_filter_rev_add
df_cit$proposal_choice_ <- ifelse(prop_cit_filter_rev_add$proposal_choice=='FOR',1,0) 
df_cit$voted_choice_ <- ifelse(prop_cit_filter_rev_add$voted_choice=='FOR',1,0) 


df2 = df_cit[df_cit$address==address_both[i],]

## final model
df = rbind(df1,df2)

  log_model <- glm(proposal_choice_ ~ voted_choice_, data = df, family = binomial)
  log_eff_both_rev[i]=log_model$coefficients[2]

  
  
} # end for


hist(log_eff_both_rev)


```

# future work



token 和 cit 没有相同的proposal



发现社团划分方法和参数对1个人的社团影响不大。具有鲁棒性。
如果社团划分越多，会造成中心化指标（方差）越大，中心化程度越高。trade-off

先定义相似性指标，然后网络聚类。

可以改进相似性矩阵。

可以考虑如何把多选的proposal信息利用上。

先以社区为单位，进行逻辑回归，得到效应，然后给同一社区内所有个体赋为相同效应。然后看所有个体效应的分布。这个分布越陡峭，甚至为一条直线时，说明去中心化程度越好。所以方差或者峰度可以作为衡量中心化程度的一种指标。


理想情况下，每个人的effect应该一致，即权利人人平等。

在做反事实研究时，一个group中每个人的票都反。

可以加一个参数的灵敏度分析。

综合考虑：可以把token和cit的数据合并，做逻辑回归。

可以对最后的effect多算几个中心化指标，然后最后结论根据==多数指标的结论。给一个table。

可以把house的数量设为可变的，k个。

# question

cit 中voted choice中哪些是FOR，哪些是AGAINST？？

