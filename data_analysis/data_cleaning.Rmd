---
title: "Blockchain Project"
author: "Yang Yujie 3036044363"
date: "2024-07-11"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




# token_house

```{r}
prop_token = read.csv("/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/token_house_proposals_votes.csv")


colnames(prop_token)
```
```{r}
apply(prop_token,2,function(x) length(unique(x)))
```
有一些proposal没有title

```{r}
apply(prop_token,2,typeof)
```

```{r}
library(dplyr)
prop_token %>% filter(title == "") %>% select(proposal_id) %>% unique
```


```{r}
library(dplyr)


token_number_people =  prop_token  %>% group_by(proposal_id) %>% summarise(number_people= length(unique(address)))

table(token_number_people$number_people)
```
绝大部分proposal都是200个人都投票了。(看是否能去掉投票少的proposal，看一下voting——power)





```{r}
# 过滤掉参与次数较少的address

token_address_num =  prop_token  %>% group_by(address) %>% summarise(number_prop= length(unique(proposal_id)))

length(unique(prop_token$address))
token_address_num %>% filter(number_prop >= 5 ) %>% dim
token_address_num_5 = token_address_num %>% filter(number_prop >= 5 )

prop_token_filter = prop_token %>% filter(address %in% token_address_num_5$address)

```

Nearly a half of address in the token house only participate in less than 5 proposals.



# citizen house

```{r}


prop_cit = read.csv('/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/citizen_house_proposals_votes.csv')

colnames(prop_cit)
```

```{r}
apply(prop_cit,2,function(x) length(unique(x)))

```
proposal, proposal_id ，snapshot and title 是一一对应的。因此此处只保留一列即可，保留id.

```{r}
library(dplyr)


cit_number_people =  prop_cit  %>% group_by(proposal_id) %>% summarise(number_people = length(unique(address)))

table(cit_number_people$number_people)
```

cit中全部的proposal都是200人一起投票。


```{r}
# 过滤掉参与次数较少的address

cit_address_num =  prop_cit  %>% group_by(address) %>% summarise(number_prop= length(unique(proposal_id)))

length(unique(prop_cit$address))
cit_address_num %>% filter(number_prop >= 5 ) %>% dim
cit_address_num_5 = cit_address_num %>% filter(number_prop >= 5 )

prop_cit_filter = prop_cit %>% filter(address %in% cit_address_num_5$address)

```



# Between token and citizen

```{r}
prop_token %>% distinct() %>% dim()

prop_cit %>% distinct() %>% dim()

prop_token_filter %>% distinct() %>% dim()

prop_cit_filter %>% distinct() %>% dim()
```
两个数据表中没有重复的行。

```{r}
# 查找两列的相同元素

length(intersect(unique(prop_token$address),unique(prop_cit$address)))

length(intersect(unique(prop_token_filter$address),unique(prop_cit_filter$address)))

length(intersect(unique(prop_token_filter$proposal_id),unique(prop_cit_filter$proposal_id)))
```

token$address and cit$address一一对应，有311个同时在token 和 cit中出现。（token 和 cit 的address人数各有1000个左右）


token house , cit house 中没有相同的proposal id




# voting results

```{r}
voting_res = read.csv('/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/voting_results_summary.csv')

colnames(voting_res)
```

```{r}
apply(voting_res,2,typeof)
```
```{r}
intersect(unique(prop_cit$proposal_id),unique(prop_token$proposal_id))
length(unique(prop_cit$proposal_id))
length(unique(prop_token$proposal_id))
length(unique(voting_res$proposal_id))
```
投票结果中proposal的数量和cit+token的proposal数量对上了。




```{r}
length(unique(prop_token$proposal_id)) # 76
length(intersect(unique(prop_token$proposal_id),unique(voting_res$proposal_id))) # 

length(unique(prop_cit$proposal_id)) # 92
length(intersect(unique(prop_cit$proposal_id),unique(voting_res$proposal_id))) # 59



```
voting_res的清洗有点问题,有的proposal是multiple，所以for就是0


先不考虑 abstain 和 multiple选择的
```{r}

voting_res %>% filter(voted_choice %in% c('FOR','AGAINST')) %>% dim()

prop_token_filter %>% filter(voted_choice%in% c('FOR','AGAINST')) %>% dim()

prop_cit_filter %>% filter(voted_choice %in% c('FOR','AGAINST')) %>% dim()

voting_res_filter =voting_res %>% filter(voted_choice %in% c('FOR','AGAINST')) 

prop_token_filter = prop_token_filter %>% filter(voted_choice%in% c('FOR','AGAINST')) 

prop_cit_filter = prop_cit_filter %>% filter(voted_choice %in% c('FOR','AGAINST')) 
```
```{r}
#把proposal最终结果信息加入进来
 length(intersect(unique(prop_token_filter$proposal_id),unique(voting_res_filter$proposal_id)))
 length(intersect(unique(prop_cit_filter$proposal_id),unique(voting_res_filter$proposal_id)))
length(unique(prop_token_filter$proposal_id))
length(unique(prop_cit_filter$proposal_id))
## token 和 cit中的proposal都在voting result里面
library(plyr)
colnames(voting_res_filter)[5] = 'proposal_choice'


voting_res_filter_final = data.frame() ##因为voting res filter里面一个prop id有两行数据，分别是For的票数和Ag的票数，现在需要比较大小，得出一个最终结论。

for (i in 1:unique(length(voting_res_filter$proposal_id))) {
  D = voting_res_filter %>% filter(proposal_id == unique(voting_res_filter$proposal_id)[i])
  if(dim(D)[1]==2){
  D_for = D %>% filter(proposal_choice=='FOR')
  D_for_p = D_for$voting_power
   D_Ag = D %>% filter(proposal_choice=='AGAINST')
  D_Ag_p = D_Ag$voting_power
  
  if (D_for_p>D_Ag_p) {
    voting_res_filter_final = rbind(voting_res_filter_final,D_for)
  } else{
    voting_res_filter_final = rbind(voting_res_filter_final,D_Ag)
  }
  }# end dim(D)[1]==2
  else{
    voting_res_filter_final = rbind(voting_res_filter_final,D)
  }
}

prop_token_filter_add = merge(voting_res_filter_final[c('proposal_id','proposal_choice')],prop_token_filter[c('address','proposal_id','voted_choice')],by = 'proposal_id')


prop_cit_filter_add = merge(voting_res_filter_final[c('proposal_id','proposal_choice')],prop_cit_filter[c('address','proposal_id','voted_choice')],by = 'proposal_id')


dim(prop_token_filter)
dim(prop_cit_filter)
```




```{r}
prop_token_filter_add %>% filter(address == prop_token_filter_add$address[1],proposal_id == prop_token_filter_add$proposal_id[1]) 
```



```{r}
#算token中，每两人参与了有多少共同的proposal
token_1 = prop_token_filter %>% filter(address == unique(address)[1])
token_2 = prop_token_filter %>% filter(address == unique(address)[2])
token_12 = inner_join(token_1,token_2,by = 'proposal_id')

length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

M = matrix(rep(0,length(unique(prop_token_filter$address))^2),nrow =length(unique(prop_token_filter$address)) )

for (i in 1:length(unique(prop_token_filter$address))) {
  for (j in i:length(unique(prop_token_filter$address))) {
    token_1 = prop_token_filter %>% filter(address == unique(address)[i])
    token_2 = prop_token_filter %>% filter(address == unique(address)[j])
    M[i,j] = length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

  }
  
}

write.csv(data.frame(M),file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_token.csv')
```



```{r}
#算cit中，共同参与的proposal数量
token_1 = prop_cit_filter %>% filter(address == unique(address)[1])
token_2 = prop_cit_filter %>% filter(address == unique(address)[2])
token_12 = inner_join(token_1,token_2,by = 'proposal_id')

length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

cit_M = matrix(rep(0,length(unique(prop_cit_filter$address))^2),nrow =length(unique(prop_cit_filter$address)) )

for (i in 1:length(unique(prop_cit_filter$address))) {
  for (j in i:length(unique(prop_cit_filter$address))) {
    token_1 = prop_cit_filter %>% filter(address == unique(address)[i])
    token_2 = prop_cit_filter %>% filter(address == unique(address)[j])
    cit_M[i,j] = length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

  }
  
}

write.csv(data.frame(cit_M),file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_cit.csv')
```



 






```{r}
#算token and cit house中，每两个人意见一致的proposal数量。
token_1 = prop_token_filter_add %>% filter(address == unique(address)[1])
token_2 = prop_token_filter_add %>% filter(address == unique(address)[2])
token_12 = inner_join(token_1,token_2,by = 'proposal_id')

length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

M_token = matrix(rep(0,length(unique(prop_token_filter_add$address))^2),nrow =length(unique(prop_token_filter_add$address)) )

for (i in 1:length(unique(prop_token_filter_add$address))) {
  for (j in i:length(unique(prop_token_filter_add$address))) {
    token_1 = prop_token_filter_add %>% filter(address == unique(address)[i])
    token_1 = token_1[c('proposal_id','proposal_choice')]
    token_2 = prop_token_filter_add %>% filter(address == unique(address)[j])
    token_2 = token_2[c('proposal_id','proposal_choice')]
    
    M_token[i,j] = dim(intersect(token_1,token_2))[1]

  }
  
}

write.csv(data.frame(M_token),file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_token_samechoice.csv')
####
token_1 = prop_cit_filter_add %>% filter(address == unique(address)[1])
token_2 = prop_cit_filter_add %>% filter(address == unique(address)[2])
token_12 = inner_join(token_1,token_2,by = 'proposal_id')

length(intersect(unique(token_1$proposal_id),unique(token_2$proposal_id)))

M_cit = matrix(rep(0,length(unique(prop_cit_filter_add$address))^2),nrow =length(unique(prop_cit_filter_add$address)) )

for (i in 1:length(unique(prop_cit_filter_add$address))) {
  for (j in i:length(unique(prop_cit_filter_add$address))) {
    token_1 = prop_cit_filter_add %>% filter(address == unique(address)[i])
    token_1 = token_1[c('proposal_id','proposal_choice')]
    token_2 = prop_cit_filter_add %>% filter(address == unique(address)[j])
    token_2 = token_2[c('proposal_id','proposal_choice')]
    
    M_cit[i,j] = dim(intersect(token_1,token_2))[1]

  }
  
}

write.csv(data.frame(M_cit),file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_cit_samechoice.csv')
```

```{r}
M_cit = read.csv(file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_cit_samechoice.csv')
# 把三角矩阵变成全矩阵
M_cit = M_cit[,-1]
M_cit_full = as.matrix(M_cit)

for (i in 2:dim(M_cit_full)[1]) {
  for (j in 1:(i-1)) {
    M_cit_full[i,j] = M_cit[j,i]
  }
}

sum(M_cit_full == t(M_cit_full))

dim(M_cit_full)
#########


M_token = read.csv(file = '/Users/yangyujie/hku-phd/year1 sem2/Blockchain/data/M_token_samechoice.csv')
# 把三角矩阵变成全矩阵
M_token = M_token[,-1]
M_token_full = as.matrix(M_token)

for (i in 2:dim(M_token_full)[1]) {
  for (j in 1:(i-1)) {
    M_token_full[i,j] = M_token[j,i]
  }
}


sum(M_token_full == t(M_token_full))

dim(M_token_full)
```


# visualize

```{r}
M_token_tranc = M_token_full
for (i in dim(M_token_full)[1]) {
  for (j in dim(M_token_full)[1]) {
    if (M_token_tranc[i,j]<= 3) {
      M_token_tranc[i,j] = 0
    }
  }
}

# 安装并加载 igraph 包
#install.packages("igraph")
library(igraph)

# 示例相似性矩阵
similarity_matrix <- M_token_tranc

# 创建图对象
g <- graph_from_adjacency_matrix(similarity_matrix, mode = "undirected", weighted = TRUE, diag = FALSE)

# 设置图形布局
layout <- layout_with_fr(g)

# 设置节点颜色和大小
V(g)$color <- "skyblue"
V(g)$size <- 1

# 设置边的宽度和颜色
E(g)$width <- E(g)$weight * 2
E(g)$color <- "grey"

# 绘制美化后的网络图
plot(g, layout = layout, edge.arrow.size = 0.2, vertex.label.color = "black", vertex.label.dist = 1.5)

# 进行Louvain社团检测
community <- cluster_louvain(g,resolution = 1.5) #resolution越大，社团数越多

# 使用 Leiden 算法进行社团划分
community_leiden <- cluster_leiden(g, resolution_parameter = 2)


### 试图进行调优参数
best_mod = 0
best_res = 0
for (i in seq(0.01,3,0.01)) {
  community <- cluster_louvain(g,resolution = i)
  mod = modularity(community)
  if (mod>best_mod || mod>0.1) {
    best_mod = mod
    best_res = i
  }
}

community <- cluster_louvain(g,resolution = best_res)

#但发现使模块度最大的参数，造成只有一个group，显然不行。


# 打印社区结构
print(community)
print(community_leiden)

# 绘制网络图，按照社团进行着色
plot(community, g, vertex.size = 15, vertex.label = NA, 
     edge.arrow.size = 0.5, 
     vertex.color = membership(community) + 1)


```

```{r}
library(ggplot2)
Louvain_member = community$membership  #这个的效果感觉更好
leiden_member = community_leiden$membership

#print(leiden_member)
table(Louvain_member)
table(leiden_member)



token_row_sum = rowSums(M_token_full)
length(unique(prop_token_filter$address))# prop_token_filter中的address数量和矩阵一一对应



hist(token_row_sum[leiden_member==1])

hist(token_row_sum[leiden_member==2])

hist(token_row_sum[leiden_member==3])

hist(token_row_sum[Louvain_member==1])

hist(token_row_sum[Louvain_member==2])

hist(token_row_sum[Louvain_member==3])
###
d = prop_token_filter %>% filter(address %in% unique(address)[Louvain_member==1] )
hist(d$voting_power)

d = prop_token_filter %>% filter(address %in% unique(address)[Louvain_member==24] )
hist(d$voting_power)

d = prop_token_filter %>% filter(address %in% unique(address)[Louvain_member==14] )
hist(d$voting_power)

```

```{r}
K_Lou = prop_token_filter %>% filter(address == unique(address)[Louvain_member==48])
mean(K_Lou$voting_power)
#1-682434.4
K_Lei = prop_token_filter %>% filter(address == unique(address)[leiden_member==41])
mean(K_Lei$voting_power)

#1-1997128


# 把那些一个人成一个社区的挑出来
freq= table(Louvain_member)
Lou_1 = as.numeric(names(freq[freq == 1]))

K_Lou_1 = prop_token_filter %>% filter(address %in% unique(address)[Louvain_member%in%as.numeric(names(freq[freq == 1]))])

hist(K_Lou_1$voting_power)
###
freq= table(leiden_member)
Lei_1 = as.numeric(names(freq[freq == 1]))

K_Lei_1 = prop_token_filter %>% filter(address %in% unique(address)[leiden_member%in%as.numeric(names(freq[freq == 1]))])

hist(K_Lei_1$voting_power)


hist(token_row_sum[leiden_member%in%Lei_1])

hist(token_row_sum[Louvain_member%in%Lou_1])


```

选择Lou



# future work

prop_token_filter_add 有点问题

token 和 cit 没有相同的proposal

cit的voting power不是0，1？

发现社团划分方法和参数对1个人的社团影响不大。具有鲁棒性。
如果社团划分越多，会造成中心化指标（方差）越大，中心化程度越高。trade-off

先定义相似性指标，然后网络聚类。

可以改进相似性矩阵。

可以考虑如何把多选的proposal信息利用上。

先以社区为单位，进行逻辑回归，得到效应，然后给同一社区内所有个体赋为相同效应。然后看所有个体效应的分布。这个分布越陡峭，甚至为一条直线时，说明去中心化程度越好。所以方差或者峰度可以作为衡量中心化程度的一种指标。


理想情况下，每个人的effect应该一致，即权利人人平等。

在做反事实研究时，一个group中每个人的票都反。

可以加一个参数的灵敏度分析。

# question



